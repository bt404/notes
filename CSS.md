1. css 的框模型是由外边距、边框、内边距和元素构成，height 和 width 设置的是 element 的高度和宽度。内边距用来显示背景，即背景应用于由内容和内边距、边框组成的区域。外边距默认透明，不会遮挡住后面的元素。

2. 只有指定了 !DOCTYPE 时，IE7/8 才支持属性选择器（[]）。

3. 用百分比显示数值时，默认是根据其占父元素的该属性值比值计算得出，父元素改变时，其也改变。因为width是element的宽度，所以设置width为百分数时，表示该元素所占父级element宽度的百分比，二者都不包括border和margin的宽度。

4. 元素有4种定位，默认为static，元素根据自己在html文档中的位置定位，此时top、bottom、left和right等4个属性设置无效。

5. 通过设置为absolute或fixed，元素脱离自己在html文档中的位置，并生成一个新的块级元素（无论他之前是什么级别框），即从文档流中删除不再占位。此时使用top等4个属性规定该块级元素的外边距边框相对他的最近已定位祖先元素（若不存在则为最初包含块，对于fixed来说始终是浏览器窗口）外边距边框的位置偏移，可以存在父级元素不是absolute而子元素是。

6. 由于absolute可能存在覆盖，可以设置z-index来规定元素间的叠放次序。

7. relative同样是相对于父级元素位置设定，但不同于absolute和fixed，元素本身并不从文档流中删除。

8. 设置relative可能导致该元素覆盖下面的元素，下一个元素永远是相对于上一个元素本该出现的位置定位（无论该元素是否是relative），所以上一个元素如果设置了relative并确定top等值，那么元素可能覆盖后面的元素。

9. 设置行内元素的垂直内边距、边框和外边距不影响行内框的高度。

10. float属性的框同样不占用html文档中的位置，他向左/右移动，直到遇到包含框或者另一个浮动框为止。所以浮动框同样可能覆盖html文档中的其他框。

11. 有时一个元素被迫折行时，原因大多情况下是父级元素指定了宽度，内框宽度又无法盛下框内元素。不同浏览器（往往是IE）对宽度的渲染会有偏差（比如见过一次IE少了1px），所以可以调整框内元素宽度来实现改变，必要时可以使用IE的hack来真对IE单独设置宽度。

12. ff下，两个float元素（一left一right），可能会造成其中一个元素覆盖住另一个元素。这时可以通过将两个元素设置relative，再分别设置对应的z-index来改变二者的叠放次序。

13. ff下，设置relative的元素，除了设置top，有时还需设置right来限制它的位置，而chrome可以自动规范。

14. IE下遇到设置sans字体导致父元素被挤破从而折行的情况，有时在IE下遇到问题，首先应该确认在其他机器的IE下是否有同样问题；然后应该确认原生IE和IE仿真模式下是否显示也有不同。

15.

