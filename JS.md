1. {}的hasOwnProperty方法返回对象是否包含某个属性，只能检测对象自身的属性，不能检测从原型中继承来的属性。

2. JS中的根对象是Object.prototype对象。

3. 一个对象的prototype只能通过`Object.getPrototype()`方法或者自身的`__proto__`属性来获取；通过对该对象赋值`prototype`属性并不会覆盖它的原型，而是为其增加了一个名为`prototype`的属性，而它的原型保持不变。

4. 使用`new`创建一个对象的过程：先从`Object.prototype`克隆一个对象，然后为它设置正确的`__proto__`即它的原型，最后通过外部构造器函数为其设置属性，最后返回对象。

5. JS函数的两个作用：普通函数；函数构造器。

6. 一个对象的属性与其构造器函数原型无关，属性的构造器函数为其设置了自身属性；构造器原型使得创建的对象继承了额外的可追溯的属性；即一个是自身的属性，另一部分是从构造器继承来的。

7. 承上一条，为一个对象设置与构造器原型同名的属性值，则对象本身发生变化：本质是多了一个属性。而构造器原型保持不变，通过构造器创建新的对象，它所继承的原型属性值也不变。

8. `<script>`标签中根据是否有`async`和`defer`分为3种处理情况：
  * 没有标记：此时DOM暂停解析，同步下载并执行script，然后恢复解析。
  * async：DOM解析和script下载并行执行，等下载完成后暂停解析，等待script执行完成后恢复解析。
  * defer：DOM解析和script下载并行执行，下载完成后继续解析，等DOM完成解析后再执行script。

9. JSONP的原理是在script中编写回调函数，然后编写script标签，其中src设置为接口地址，并且通过url参数的方式传递回调函数名。接口获取函数名，并且将数据和函数绑定拼装为回调函数调用数据参数的执行语句字符串返回给客户端。客户端获取该脚本内容（内容是回调函数执行字符串）后会执行回调函数。

10. 事件触发有capture和bubble两种方式， 前者是从父元素向子元素依次触发handler，后者反之。事件代理是指在父元素上绑定handler，然后通过事件冒泡来触发handler，这样既减少了事件绑定的数量提升性能，又能在新添加子元素也不需要为子元素添加handler。

11. 
